## Serial垃圾回收器

是最古老的垃圾回收器，使用单线程收集，在young区达到safepoint的时候会使用标记复制算法对年轻代进行垃圾回收，标记复制算法就是将存活下来的对象直接复制进入survivor区，之后直接清除Eden区，其中年轻代中eden区和survivor的比例是8：1是串行垃圾回收的默认比例，所以在串行垃圾回收算法中永远都会有10%的堆内存是会被浪费掉的。而在老年代达到safepoint的时候，就会触发fullgc，串行gc老年代的算法是标记-整理算法，首先是将不用的对象进行清楚，之后在将存活的对象都向内存空间的一端移动，这样就保证大的对象可以放入。串行gc最大的缺点就是，每次gc的时候都会强制停止其他所有工作的线程，这样对于一些需要实时性的服务来说是非常致命的。但是串行gc也有优点，就是因为他在gc的时候所有线程暂停，所以程序就不会创建新的对象，所以串行gc的占用是很小的

# ParallelGC并行gc

是jdk8中默认的gc，顾名思义就是可以通过多个线程对垃圾对象进行收集，堆内存依旧是分为了年轻代和老年代，年轻代和老年代的比例是1：3，但是在年轻代中若没有指定比例参数则eden区和survivor区的比例是1：1，但是在并行gc中有一个参数是-XX:UseAdaptiveSizePolicy将这个参数打开后，虚拟机会根据系统当前运行情况去调整年轻代中eden区和suvior区的比例，同时年轻代和老年代的大小也会动态的改变。这样就可以根据我们的业务需求来调整我们垃圾回收策略的目的，目的是限制最大的停顿时间-XX:MaxGCPauseMills，或者是关注吞吐量-XX:GCTimeRatio。并行gc无论是在minorgc还是majorgc的时候都会stw，只不过时间比串行gc短。

# CMS收集器

cms收集器有4个过程分别是

1）初始标记

2）并发标记

3）重新标记

4）并发清理

cms收集器在做gc的时候是和用户线程一起并发来做清除的，所以需要消耗用户运行时的cpu资源，所以cmsgc最好用于多核的cpu作为gc策略。虽说cms清除的时候不会stw，但是其中初始标记和重新标记的时候也会触发stw。cms收集器有个缺点就是，之前说的串行gc和并行gc都是可以等待到老年代满的时候才会到达safepoint才会触发fullgc，而cms不同，它的清理是和用户线程一起并发的，所以需要预留一些内存给到用户线程进行运行

# G1收集器

g1收集器，不再遵循之前的内存分配，g1不在坚持固定大小和固定数量的分代区域规划，而是将堆内存分割成一个个等量的“region”，每一个region可以根据需要区被当成年轻代或者老年代，而对于大的对象，g1则将他们连续的存放在一些连续的称作为Humongous Region的内存中，并且被当作老年代来看待。g1垃圾回收是维护一个优先级列表，在用户允许的最大暂停时间-XX:MaxGCPauseMills中去回收最有具有回收价值的对象.